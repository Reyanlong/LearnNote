### **deque 容器**
```c++
1.deque是“double-ended queue”的缩写。

2.和vector一样，deque也支持随机存取。

3.vector是单向开口的连续空间，deque则是一种双向的连续性空间。

4.所谓双向开口，意思是可以在头尾两端分别做元素的插入和删除操作。

5.vector当然也可以在头尾两端进行插入和删除操作，但是头部插入和删除操作效率奇差，无法被接受。
```
```c++
1. deque的空间连接功能，不会频繁的分配空间，而是中控器使用地址将多段空间连接起来

2. 双端插入和删除元素效率较高
3. 指定位置插入也会导致数据元素移动，降低效率
4. 可随机存取，效率高
```
```c++
1. deque的构造
deque<int> de1;
deque<int> de2(de1.begin(), de2.end());
deque<int> de3(de2);


2.assign方法
   将区间[first,last)的元素赋值到当前的vector容器中，或者赋n个值为x的元素到vector容器中。
   这个容器会清除掉vector容器中以前的内容。


/** 得到容器的元素数量 */
size方法

/** bool 型判空 */
empty方法

/** 重新设定元素个数，大了补默认值，小了删除 */
resize方法

/** 头部添加元素 */
push_front方法
/** 尾部添加元素 */
push_back方法

/** 头部删除元素 没有返回值*/
pop_front方法
/** 尾部删除元素 没有返回值*/
pop_back方法
```
```c++
/** 返回首元素的引用 */
front方法
/** 返回尾元素的引用 */
back方法

1. 删除的时候要谨慎，先用front方法看看是不是自己要删除的，确定后再删除元素。
```
```c++
1.右值引用跟拷贝构造有关
定义右值引用的格式如下:

类型 && 引用名 = 右值表达式;

可以取地址的，有名字的，非临时的就是左值；
不能取地址的，没有名字的，临时的就是右值；


2.右值引用用来绑定到右值，绑定到右值以后本来会被销毁的右值的生存期会延长至与绑定到它的右值引用的生存期。

3.右值引用的存在并不是为了取代左值引用，而是充分利用右值(特别是临时对象)的构造来减少对象构造和析构操作以达到提高效率的目的。

4.加了const后竟然不能取地址
```

#### **erase返回的是下一个位置的迭代器,当前使用的迭代器会失效**
```c++
1.容器里是指针一定要,先释放空间再删除指针.

2.erase使用过后,当前迭代器会失效.erase返回后一位元素的迭代器,用返回值重新设置当前迭代器.

3.容器的end方法的返回值随时在变

4.用rbegin遍历也是++

5.迭代器不能随便改值.
```


```c++
1.容器存放自定义类是拷贝构造


//排序规则
bool myCompare(Player& p1, Player& p2){
   return p1.mScore < p2.mScore;
}

//根据选手分数排名 sort默认从小到大 希望从大到小
sort(v.begin, v.end, myCompare);
```



### **stack容器**
```c++
1.栈不能遍历,不支持随机存取,只能通过top从栈顶获取和删除元素,不提供迭代器
2.先进后出
```
```c++
/** 构造函数 */

stack<T> stkT;     //采用模板类实现,stack对象的默认构造形式;
stack(const stack& stk);   //拷贝构造函数
```
```c++
/** stack赋值操作 */

stack& operator=(const stack& stk);  //重载等号运算符
```
```c++
/** stack数据存取操作 */

push(elem); //向栈顶添加元素
pop();     //从栈顶移除第一个元素
top();      //返回栈顶元素
```
```c++
/** stack大小操作 */
empty(); //判断堆栈是否为空
size();   //返回堆栈的大小
```
```c++

/** emplace(T(构造参数)); */
1.emplace的运行逻辑是,直接在容器中构造一个对象,减少了调用拷贝构造这一步.需要传入构造需要的参数.

/** push(T(构造参数)); */
2.push的运行逻辑是,先调用对象的构造函数,然后再调用对象的拷贝构造函数.


//第一点，push 的操作可以直接用于emplace：
//1.直接传入对象（int, double 或者 构造好了的对象）

//假设栈内的数据类型是data
class data {
  int a;
  int b;
public:
  data(int x, int y):a(x), b(y) {}
};
//push
data d(1,2);
S.push(d) 或 S.emplace(d);


//2.在传入时候构造对象
S.push(data(1,2));
S.emplce(data(1,2));

// 3.emplace可以直接传入构造对象需要的元素，然后自己调用其构造函数！
S.emplace(1,2)


```
```c++
1.意思是，emplace这样接受新对象的时候，自己会调用其构造函数生成对象然后放在容器内（比如这里传入了1，2，它则会自动调用一次data(1,2))

2.而push，只能让其构造函数构造好了对象之后，再使用复制构造函数！

3.相当于emplace直接把原料拿进家，造了一个。而push是造好了之后，再复制到自己家里，多了复制这一步。

4.所以emplace相对于push，使用第三种方法会更节省内存。


5.注意：emplace_back(type) 对应 push_back(type)

       emplace(i, type) 对应于 insert(type, i)

       emplace_front(type) 对应于 push_front()

6.对于stack 和 queue，只有push操作，所以也只有emplace操作，此时它们是相对应的。
```


### **queue容器**
```c++
1.先进后出,一端插入,另一端删除
2.不能进行遍历,不提供迭代器,不支持随机访问
```

```c++
1.构造函数
queue<T> queT;     //模板构造
queue(const queue<T>& queT);     //拷贝构造
```
```c++
2.存取 插入 删除
push      //往队尾添加元素
pop        //从队头移除第一个元素
back       //返回最后一个元素
front      //返回第一个元素
```
```c++
3.赋值操作
queue& operator=(const queue& que);
```
```c++
4.queue的大小操作
empyt       //判断队列是否为空
size         //返回队列的大小
```
```c++
5.forName    // 调用构造
```



